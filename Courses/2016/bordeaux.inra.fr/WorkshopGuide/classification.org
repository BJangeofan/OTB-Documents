** Réaliser une classification supervisée                            :slides:
*** Objectifs et Données
**** Objectifs
      Les objectifs sont les suivants:
     - Connaître les différentes applications consistuant la procédure
       de classification supervisée
     - Utiliser différents algorithmes pour l'apprentissage
     - Savoir mesurer les performances de la classification
     - Connaître les post-traitements applicables à une classification
**** Données
     Les données sont disponibles dans le répertoire /LS8/ (TODO: mettre à jour)
*** Déroulement
    les étapes de l'exercice sont les suivantes:
    1. Introduction aux données landsat8
    2. Classification mono-date
    3. Classification multi-date
    4. Classification avec profil de NDVI
    5. Post-traitements de la classification
    
*** Présentation des données
    TODO:

*** Classification supervisée
    TODO:

*** Algorithme SVM
    TODO:

*** Algorithme RF
    TODO:

*** Matrice de confusion
    TODO:


** Réaliser une classification supervisée                           :guide:
*** Description                                                        :desc:
**** Résumé

     Cet exercice permet de se familiariser avec les applications de
     classification supervisée pixellique de l'Orfeo ToolBox, en
     utilisant une série multi-temporelle Landsat8 et un vrai jeu de
     données de référence pour la supervision.

**** Pré-requis
     
     - Logiciels installés (Monteverdi et Orfeo ToolBox)
     - Données téléchargées
     - Connaisance du mécanisme des applications de l'Orfeo ToolBox (voir exercice correspondant)
     - Notions de classification supervisée
     
**** Objectifs

     Les objectifs sont les suivants:
     - Connaître les différentes applications consistuant la procédure
       de classification supervisée
     - Utiliser différents algorithmes pour l'apprentissage
     - Savoir mesurer les performances de la classification
     - Connaître les post-traitements applicables à une classification

*** Étapes                                                            :steps:

**** Introduction aux données LANDSAT 8

    Dans l'archive de données, le dossier (TODO: ajouter chemin) contient neuf
    images Landsat 8 aux dates suivantes:
    
     |------------|
     | 2014-03-09 |
     | 2014-04-01 |
     | 2014-04-17 |
     | 2014-05-28 |
     | 2014-06-20 |
     | 2014-07-31 |
     | 2014-09-01 |
     | 2014-10-03 |
     | 2014-10-26 |
     |------------|

    Ces images sont chacune multispectrales avec les septs bandes du capteur OLI:

    |---+---------------------|
    | 0 | Coastal aerosol     |
    | 1 | Blue                |
    | 2 | Green               |
    | 3 | Red                 |
    | 4 | Near Infrared (NIR) |
    | 5 | SWIR 1              |
    | 6 | SWIR 2              |
    |---+---------------------|

    Au total, c'est donc 63 bandes qui representent chaque pixel.
    Les images sont encodés sur 16 bits.

    Ouvrez une image dans monteverdi et régler les bandes pour un affichage en
    vrais couleurs (rouge, vert, bleu).

    Ouvrez les neuf images et remarquez les changements.

    Les fichiers (TODO LS8/training/training.shp) et (TODO
    LS8/testing/testing.shp) contiennent des polygones qui définissent 11
    classes sur l'ensemble de la scène:

    |------+-----------------------------|
    | Code | Nom                         |
    |------+-----------------------------|
    |   11 | Éte                         |
    |   12 | Hiver                       |
    |   31 | Foret feuilles caduques     |
    |   32 | Foret feuilles persistantes |
    |   34 | Pelouses                    |
    |   36 | Lande ligneuse              |
    |   41 | Bati                        |
    |   51 | Eau                         |
    |  211 | Prairie                     |
    |  221 | Verger                      |
    |  222 | Vigne                       |
    |------+-----------------------------|

    Ouvrez un des fichiers de polygones dans QGIS. La table d'attributs est
    accessible depuis clic-droit sur la couche -> ouvrir la table des attributs.
    Chaque label est visible et la liste est filtrable par expression SQL.

    Les polygones sont répartis en deux ensembles: apprentissage (training) et
    validation (testing).

**** Classification d'une date

    Nous allons commencer par réaliser sur une seule date toutes les
    étapes qui constituent la procédure de classification supervisée:

       1. Calcul des statistiques
       2. Apprentissage du modèle
       3. Utilisation du modèle (classification)
       4. Rendu
       5. Validation

    Dans la suite du TP, vous réalisez d'autres classifications sur d'autres
    images. Un conseil est donc de travailler dans un répertoire par sous
    partie, par exemple /classif1/.

    Créez un répertoire /classif1/.

***** Calcul des statistiques

    Les variables doivent êtres comparables entre chaque image. La première
    étape est le calcul de statistiques pour que les données puissent être
    normalisés: moyenne nulle et écart-type de 1.
    
    Choisissez une image à classifier, puis, dans le répertoire classif1
    utilisez l'application *ComputeImageStatistics* pour produire le fichier de
    statistiques.

***** Apprentissage du modèle

    L'application *TrainImageClassifier* permet d'apprendre un modèle pour
    différentes méthodes de classifications. Regardez la documentation de cette
    application et créez un modèle pour la méthode /libsvm/. Les paramètres
    à régler sont:

    - io.il :: l'image d'entrée
    - io.vd :: le fichier vectoriel d'apprentissage (training.shp)
    - io.imstat :: le fichier xml de statistique calculé précédement
    - classifier :: la méthode, ici utilisez /libsvm/
    - io.out :: le nom du fichier modèle en sortie, par exemple /model.rf/

    D'autres paramètres sont important aussi:
    - sample.vfn CODE :: indique que la colonne SQL des labels porte le nom CODE
    - sample.vtr 0 :: Ratio de l'emsemble d'apprentissage sur l'ensemble de
      validation. Zero ici car nous utilisons notre propre découpe.
    - sample.mt :: Nombre maximum d'échantillons par classe. La valeur par défaut
      est 1000. La réduire permet d'accélérer significativement le temps
      d'apprentissage.

***** Utilisation du modèle

   Une fois le modèle de classification appris, il peut être utilisé pour
   classifier tout les pixels de l'image.

   Utilisez l'application *ImageClassifier*, en specifiant le modèle créé dans
   l'étape précédente.

***** Rendu

   La sortie de l'étape précédente est une image .tif qui associe à chaque pixel
   une classe. Pour visualiser cette image, l'application *ColorMapping* permet
   d'associer à chaque label une couleur RGB et de générer une image de
   visualisation.

   Utilisez l'application ColorMapping avec la table de couleur fournie
   ~color_map.txt~.

***** Validation

  Les labels utilisés lors de l'étape d'apprentissage ne représentent que 30%
  des polygones. les 70% restant sont dans le fichier testing/testing.shp et
  servent à evaluer les performances du modèle appris en calculant la matrice de
  confusion.

  Utilisez l'application *ComputeConfusionMatrix* avec le jeu de donnée de test
  pour produire la matrice de confusion du modèle appris.

  Le paramètre /ref.vector.field CODE/ est nécéssaire. Il indique le nom du
  champ contenant le numero de label.

  Consultez la matrice de confusion et identifiez les classes bien différenciés.

  A quel classe appartiennent le plus souvent les pixels mal classifiés ?
  Pourquoi ?

  Vous pouvez utiliser le squelette csv (~template_confusion_matrix.csv~) pour
  identifier les labels facilement.

**** Classification multidate

  Le principe de la classification multidate est d'utiliser pour chaque pixel,
  toute les dates disponibles comme des bandes spectrales supplémentaire. Avec
  les données LANDSAT 8, il s'agit donc d'utiliser 63 bandes par pixel.
  Les dates ont été choisies de façon à être réparties temporellement sur une
  année. Cela permet d'intégrer les variation saisonales qui apporte beaucoup
  d'information pour la discrimination de certaines classes.

  Avant tout, créez un repertoire /classif9/ pour cette partie.

  Les étapes sont les mêmes que précédement, mais il faut d'abord constituer une
  image de 63 bandes en concatenant les 9 images.

  Pour cela, utilisez l'application *ConcatenateImages*.

  Vérifiez ensuite que la sortie est bien une image de taille 3667x3667 de
  63 bandes sur 16 bits avec gdalinfo.

  Puis effectuez les même étapes que précédement: *ComputeImageStatistics*,
  *TrainImageClassifier*, *ImageClassifier*, *ColorMapping*, *ComputeConfusionMatrix*.
 
  *Note* utilisez cette fois la méthode Random Forest pour le modèle qui est plus
  rapide. Utilisez également les paramètres suivants qui offrent de bonnes
  performances de classification:

    Pour ne pas limiter le nombre d'échantillon par le minimum de la plus petite
    classe.
    -sample.mt 2000 :: Le nombre maximum d'échantillons d'aprentissage par
    classe.
    -classifier.rf.max 25 :: Profondeur maximum des arbres de décisions.
    -classifier.rf.min 25 :: Nombre minimum d'échantillon dans chaque noeud.

  Comparez ensuite les resultats avec la classification à une date en utilisant
  la matrice de confusion et l'image RGB.

**** Calcul d'un profil de NDVI
  
  Une image NDVI peut-être calculée pour chaque image de la série temporelle
  pour constituer un profil de NDVI. Ajouté aux bandes de l'image concaténée, ce
  profil permetra d'améliorer les performance de classification.

  Calculer une image de NDVI pour chaque image de la série temporelle en
  utilisant l'application RadiometricIndices. Prenez garde au type de sortie.

  Ouvrez les neuf images d'indices dans monteverdi pour constater l'évolution
  temporelle.

  Concatenez les neuf images d'indices en une seule pour constituer un profil
  NDVI. Ouvrez le profil dans QGIS. Visualiser le profil NDVI temporellement
  avec l'outil bouton identifier les entités, puis vue graphique.

**** Classification du profil de NDVI

  Créez un répertoire /classifNDVI/ pour cette partie.

  En suivant la même méthode que précédement, réaliser une classification de la
  série temporelle augmentée du profil NDVI.

  Les résultats sont ils améliorés par rapport à la classification multi date
  sans l'indice NDVI ?

**** Post-traitements de la classification

***** Régularisation

      principe
      commande

***** Fusion de classes

     principe
     comment décider quelle classe fusionner
     commandes
     
***** Vectorisation

     principe
     commande

** Réaliser une classification supervisée                         :solutions:
*** Classification mono-date


    #+BEGIN_EXAMPLE
    $ otbcli_ComputeImagesStatistics -il image.tif
                                   -out images_statistics.xml 
    #+END_EXAMPLE
    


    #+BEGIN_EXAMPLE
    $ otbcli_TrainImagesClassifier -io.il 
        ../../Data/LS8/LANDSAT_MultiTempIm_clip_GapF_20141026.tif 
        -io.vd ../../Data/LS8/training/training.shp 
        -sample.vfn CODE 
        -sample.vtr 0 
        -classifier libsvm 
        -io.imstat images_statistics.xml 
        -io.out model.svm
    #+END_EXAMPLE

    #+BEGIN_EXAMPLE
    $ otbcli_ColorMapping -in              labeled_image.tif
                        -method            custom
                        -method.custom.lut color_map.txt
                        -out               RGB_color_image.tif
   #+END_EXAMPLE

  #+BEGIN_EXAMPLE
  $ otbcli_ComputeConfusionMatrix \
    -in labeled_image.tif \
    -ref vector \
    -ref.vector.in ../../Data/LS8/testing/testing.shp \
    -ref.vector.field CODE \
    -out confusion_matrix.csv
  #+END_EXAMPLE
