** Segmentation                                                        :seg:
*** Description
**** Résumé
Cet exercice présente la segmentation d'images à l'aide de
l'application *Segmentation*. Vous apprendrez à produire une
segmentation raster avec différents algorithmes. L'utilisation du
format de sortie vecteur est aussi présenté, car il permet le
traitement d'images de taille très grande.

**** Pré-requis
- Connaissances de base sur les *OTB Applications* et Quantum GIS.
- Notions en segmentation d'images.
- Notions de base en SIG et formats de données vecteur.

**** Objectifs
- Utilisation de l'application *Segmentation*.
- Segmentation d'images de grande taille et importation des résultats
  dans un SIG.

*** \'Etapes

**** Introduction à l'application *Segmentation*
1. Lancez les versions en ligne de commande et graphique de l'application
2. Lisez la documentation. Quelles sont les 3 méthodes de segmentation disponibles?
3. Quels sont les 2 modes (type de format) des données en sortie?

**** Segmentation simple en mode raster
Dans cette partie de l'exercie vous utiliserez l'image
~segmentation_small_xt_phr.tif~

1. Lancez la segmentation en mode /raster/ avec la méthode des
   composantes connexes et une condition de seuil sur la distance spectrale.
2. Visualisez le résultat de la segmentation dans *Monteverdi*. Que voyez-vous?
3. Utilisez l'application *ColorMapping* afin d'améliorer la
   visualisation :
   1. Essayez la méthode /optimal/.
   2. Essayez la méthode /image/.
4. Essayez différentes conditions pour les composantes connexes et
   analysez leur influence sur les résultats. Vous pouvez essayer de
   changer le seuil de distance ou regarder la documentation pour
   connaître d'autres mots-clés.

_Trucs et astuces :_
- Utilisez le mot-clé *distance* dans l'expression pour indiquer la
  distance spectrale.
- Faites attention au type d'image en sortie.

**** Autres algorithmes de segmentation
Dans cette partie de l'exercice, vous utiliserez l'image
~segmentation_small_xt_phr.tif~

1. Lancez la segmentation en mode /raster/ à nouveau, mais utilisez la
   méthode /Mean-Shift/. Utilisez *ColorMapping* pour visualiser les résultats.
   1. Commencez par utiliser les paramètres par défaut.
   2. Modifiez ensuite les paramètres et analysez les résultats. Les
      paramètres les plus déterminants sont les rayons spatial et
      spectral (range).
2. Lancez la segmentation en mode /raster/ avec la méthode de la
   ligne de partage des eaux (/Watershed/). Servez-vous
   de *ColorMapping* pour la visualisation.
   1. Commencez par utiliser les paramètres par défaut.
   2. Modifiez ensuite les paramètres et analysez les résultats.
3. Comparez les résultats des 3 algorithmes. Conservez la meilleure
   segmentation pour l'exercice suivant.

_Trucs et astuces :_
- Il existe 2 mises en oeuvre de la méthode /Mean-Shift/. Edison est
  la version originale des auteurs de l'algorithme.

**** Passage à l'échelle : mode vecteur
Dans cette partie de l'exercice, vous utiliserez l'image
~segmentation_large_xt_phr.tif~

1. Lancez la segmentation en mode /raster/ en utilisant les meilleurs
   paramètres de l'exercice précédant, mais sur la grande
   image. Regardez la mémoire et l'utilisation du
   processeur. Qu'est-ce qui se passe?
2. Lancez à nouveau la segmentation mais en mode /vecteur/ en
   désactivant l'option *stitching*. Comparez les ressources utilisées
   avec le point précédant.
3. Ouvrez l'image et le résultat de la segmentation dans Quantum
   GIS. Ajustez les paramètres de visualisation (voir _Trucs et
   astuces_ plus bas). Qu'observez-vous?
4. Lancez à nouveau la segmentation en mode /vecteur/ en activant
   l'option *stitching*. Sauvegardez les résultats dans un nouveau
   fichier et ouvrez-le dans le même projet Quantum GIS. Quel est
   l'effet de l'option *stitching*?

_Trucs et astuces :_
- Sous Linux ou Mac OS, les ressources peuvent être consultées avec la
  commande ~top~ dans un terminal. Sous Windows,
- Appuyez sur ~Ctrl C~ pour arrêter l'application.
- Utilisez le format /sqlite/ pour sauvegarder les fichiers vecteur
  (extension ~.sqlite~).
- Quantum GIS peut importer des couches raster et vecteur.
- La visualisation de couches raster sous Quantum GIS peut être
  ajustée comme ceci :
  - click droit sur la couche, puis /Properties/
  - allez dans l'onglet /Style/
  - choisir /Use standard deviation/
  - dans /Contrast enhancement/, choisir /Stretch to MinMax/
- La visualisation de couches vecteur sous Quantum GIS peut être
  ajustée comme ceci :
  - click droit sur la couche, puis /Properties/
  - allez dans l'onglet /Style/, choisissez /Change/
  - dans /Symbol layer type/, choisissez /Outline: Simple line/
  - on peut aussi changer la couleur
- Dans Quantum GIS on peut sauvegarder le projet dans un fichier de
  façon à conserver tous ces paramètres.
        
**** Pour aller plus loin
1. En mode /vecteur/, étudiez les effets des paramètres /tilesize/,
   /simplify/ et /minsize/.
2. Comment segmenter toutes les régions de l'image sauf la végétation
   à l'aide de l'application *Segmentation* et éventuellement d'autres applications?
3. Avec les applications disponibles, comment gérer la segmentation de
   structures fortement réfléchissantes?
         
*** Solutions                                                     :solutions:

**** Getting familiar with the *Segmentation* application

***** Item 1

     To get the command-line help, run

     : $ otbcli_Segmentation

     To Get the graphical version of the *Segmentation* application, run

     : $ otbgui_Segmentation

***** Item 2

      There are three segmentation methods available in the application:
      - Mean-Shift (two different implementations)
      - Watershed (ITK implementation)
      - Connected-Components

***** Item 3

      There are two outputs available in the application:
      - The raster mode allows to segment a small image and produces a
        raster where each component of the segmentation is labeled with
        a unique integer,
      - The vector mode allows to segment larger images and produces a
        vector file where each segment of the segmentation is
        represented by a polygon.

**** Simple segmentation in raster mode

***** Item 1

      Here is the command-line to run, using a threshold of 30 on the
      spectral distance:

      : $ otbcli_Segmentation -in segmentation_small_xt_phr.tif
      :   -filter cc -filter.cc.expr "distance < 30"
      :   -mode raster -mode.raster.out first_cc.tif uint32

      Please note that we use ~uint32~ as the output type so as to be
      sure to have enough unique labels for the whole segmentation.

***** Item 2

      The segmentation result is difficult to visualize because
      neighboring segments are likely to be labeled with very close
      labels. One can notice the brightness gradient from top to bottom
      corresponding to globally increasing labels.

***** Item 3

      The following command-line allow to use the *ColorMapping*
      application in optimal mode:

      : $ otbcli_ColorMapping -in first_cc.tif 
      :   -out first_cc_color_optimal.png uint8
      :   -method optimal

      The /optimal/ color-mapping method allows to colorize each
      segment with a color maximizing contrast with the color of its
      neighbors. Please note that we use ~uint8~ as the output type
      because the *ColorMapping* application produces 8-bits data that
      can be directly viewed by any image viewer.

      Looking at the colorized image with the /optimal/ look-up table,
      we can now see that the result is over-segmented.

      : $ otbcli_ColorMapping -in first_cc.tif 
      :   -out first_cc_color_image.png uint8
      :   -method image -method.image.in segmentation_small_xt_phr.tif

      The /image/ color-mapping method allows to colorize each segment
      with its mean color in the original image, which gives a more
      realistic rendering. Note that since the results are
      over-segmented, the application will output a huge amount of text
      to the terminal.

      Here are the results of the /optimal/ (left) and /image/ (right) methods:

      #+Latex:\vspace{0.5cm}
      #+ATTR_LaTeX: width=0.45\textwidth
      [[file:Images/first_cc_color_optimal.png]] [[file:Images/first_cc_color_image.png]]

***** Item 4

      Here is another example: the following command-line will segment
      together pixels that either:
      - Have a spectral distance lower than 30,
      - Have both an intensity value greater than 400 and a spectral distance lower than 50,
      - Have both an intensity value greater than 1000,
      - Have both a near infra-red value lower than 150.

      : $ otbcli_Segmentation -in segmentation_small_xt_phr.tif
      :   -filter cc -filter.cc.expr "distance<30
      :    or (intensity_p1>400 and intensity_p2 > 400 and distance<50)
      :    or(intensity_p1 >1000 and intensity_p2>1000
      :    or (p1b4 <150 and p2b4<150))"
      :   -mode raster -mode.raster.out second_cc.tif uint32

      Here are the color-mapping results:

      #+Latex:\vspace{0.5cm}
      #+ATTR_LaTeX: width=0.45\textwidth
      [[file:Images/second_cc_color_optimal.png]] [[file:Images/second_cc_color_image.png]]

**** More segmentation algorithms

***** Item 1

      Here is the command-line to run the application using the
      Mean-Shift filter, with default parameters:

      : $ otbcli_Segmentation -in segmentation_small_xt_phr.tif
      :   -filter meanshift -mode raster
      :   -mode.raster.out meanshift.tif uint32

      A better result is obtained by using a spectral radius of 30:

      : $ otbcli_Segmentation -in segmentation_small_xt_phr.tif
      :   -filter meanshift -filter.meanshift.ranger 30 -mode raster
      :   -mode.raster.out meanshift.tif uint32

      Here are the results of this command:

      #+Latex:\vspace{0.5cm}
      #+ATTR_LaTeX: width=0.45\textwidth
      [[file:Images/meanshift_color_optimal.png]] [[file:Images/meanshift_color_image.png]]
      #+Latex:\vspace{0.5cm}


      Here is the command-line to run the application using the
      Watershed filter, with default parameters:

      : $ otbcli_Segmentation -in segmentation_small_xt_phr.tif
      :   -filter watershed -mode raster
      :   -mode.raster.out watershed.tif uint32

      Here are the results of this command:

      #+Latex:\vspace{0.5cm}
      #+ATTR_LaTeX: width=0.45\textwidth
      [[file:Images/watershed_color_optimal.png]] [[file:Images/watershed_color_image.png]]

**** Going big: the vector mode

***** Item 1

      The following command will run the application on the larger
      image:

      : $ otbcli_Segmentation -in segmentation_large_xt_phr.tif
      :   -filter meanshift -filter.meanshift.ranger 30 -mode raster
      :   -mode.raster.out meanshift.tif uint32

      Since the input image is quite large (8192 by 8192 pixels), it is
      likely that, depending on the available memory on the computer:
      - The application fails with a memory allocation error,
      - The application does not fails but starts to eat all the
        available memory.

***** Item 2

      The following command will run the application in /vector/ mode,
      without the /stitch/ option:

      : $ otbcli_Segmentation -in segmentation_large_xt_phr.tif
      :   -filter meanshift -filter.meanshift.ranger 30 -mode vector
      :   -mode.vector.out meanshift.sqlite -mode.vector.stitch 0

      In vector mode, the memory consumption is stable because the
      segmentation on a per tile basis.

***** Item 3

      In *QGis* we can see the effect of this tile-based segmentation :
      tiles border are visible in the segmentation result. On can also
      see that the segmentation produces a large number of polygons.

***** Item 4

      The following command will run the application in /vector/ mode,
      with the /stitch/ option enabled:

      : $ otbcli_Segmentation -in segmentation_large_xt_phr.tif
      :   -filter meanshift -filter.meanshift.ranger 30 -mode vector
      :   -mode.vector.out meanshift.sqlite -mode.vector.stitch 1

      Looking at the results in *QGis* one can see that most of the
      tiling effects have been removed by the stitching option (there
      might be some left). The results are therefore closer (but not
      identical) to what we would expect without the tiling strategy.

      Here is how the results look like in *QGis*. In blue, one can see
      the results without stitching, and in red, the results with
      stitching.

       #+Latex:\vspace{0.5cm}
      #+Latex:\begin{center}
      #+ATTR_LaTeX: width=0.9\textwidth
      [[file:Images/qgis_stitch.png]]
      #+Latex:\end{center}
      
**** Homework
***** Item 1
      - The /tilesize/ option allows to tune the size of the tile used
        during piecewise segmentation
      - The /simplify/ option allows to simplify the output polygons up
        to a given tolerance (always expressed in pixels). The
        resulting file will be smaller.
      - The /minsize/ option allows to discard segments whose size is
        smaller than a user-defined threshold (in pixels).

***** Item 2

      To avoid segmenting vegetation, one can build a vegetation mask
      with the *BandMath* application by thresholding the NDVI of the
      image. This mask can then be used in the segmentation application
      using the /mode.vector.inmask/ option. Note that this mode is
      only available in /vector/ mode.

***** Item 3

      Objects with high reflectance values are often more difficult to
      segment. Because of specular reflections, their inner variance is
      usually higher than other objects. Therefore, segmentation
      methods relying on comparison of neighboring pixels with respect
      to a given threshold will fail (this is the case for all three methods we
      used during the exercise).

      An idea to overcome this issue is to segment together all
      neighboring pixels with very high reflectance. This can be done
      with the connected components method, as shown earlier in the
      solution.


