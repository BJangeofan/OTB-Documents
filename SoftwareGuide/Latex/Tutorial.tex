

Well, that's it, you've just downloaded and installed OTB, lured by the promise that you will be able to do everything with it. That's true, you will be able to do everything but - there is always a {\em but} - some effort is required.

OTB use the very powerful systems of generic programing, many classes are already available, some powerful tools are defined to help you with recurrent tasks, but it is not an easy world to enter. 

These tutorial are designed to help you enter this world and grasp the logic behind OTB.

\section{Hello world}
\label{sec:TutorialHelloWorld}

\index{Hello World}

Let's start by the typical {\em Hello world} program. We are going to compile this c++ program linking to your new OTB.

First, create a new folder to put your new programs in and go into this folder. 

Then, we need to create a \code{CMakeLists.txt} that will be used by cmake to compile our program. An example of this file can be found in the \code{OTB/Examples/Tutorials} directory. The \code{CMakeLists.txt} will be very similar between your projects.

Open the \code{CMakeLists.txt} file and write in the few lines:


\small
\begin{verbatim}
PROJECT(HelloWorld)

FIND_PACKAGE(OTB)
IF(OTB_FOUND)
  INCLUDE(${OTB_USE_FILE})
ELSE(OTB_FOUND)
  MESSAGE(FATAL_ERROR
      "Cannot build OTB project without OTB.  Please set OTB_DIR.")
ENDIF(OTB_FOUND)

ADD_EXECUTABLE(HelloWorldOTB HelloWorldOTB.cxx )
TARGET_LINK_LIBRARIES(HelloWorldOTB OTBCommon OTBIO)
\end{verbatim}

\normalsize

The first line defines the name of your project as it appears in Visual Studio (it will have no effect under UNIX or Linux). The second line loads a CMake file with a predefined strategy for finding OTB \footnote{Similar files are provided in CMake for other commonly used libraries, all of them named \code{Find*.cmake}}. If the strategy for finding OTB fails, CMake will prompt you for the directory where OTB is installed in your system. In that case you will write this information in the \code{OTB\_DIR} variable. The line \code{ INCLUDE(\$\{USE\_OTB\_FILE\})} loads the \code{UseOTB.cmake} file to set all the configuration information from OTB.

The line \code{ADD\_EXECUTABLE} defines as its first argument the name of the executable that will be produced as result of this project. The remaining arguments of \code{ADD\_EXECUTABLE} are the names of the source files to be compiled and linked.  Finally, the \code{TARGET\_LINK\_LIBRARIES} line specifies which OTB libraries will be linked against this project.

\input HelloWorldOTB.tex

Once the file is written, run \code{ccmake} on the current directory. Then run \code{make}.

You finally have your program. When you run it, you will have the {\em OTB Hello World !} printed.

Ok, well done! You've just compile and execute your first OTB program. Actually, using OTB for that is not very useful, and we doubt that you downloaded OTB only to do that. It's time to move on to a more advance level.


\section{Pipeline}
\label{sec:TutorialPipeline}

\index{Reader, Writer, Pipeline}

OTB is designed to read images, process them and write or view the result. In this tutorial, we are going to see how to read and write images and the basis of the pipeline system.

First, let's add the following lines in the \code{CMakeLists.txt} file:

\small
\begin{verbatim}
ADD_EXECUTABLE(Pipeline Pipeline.cxx )
TARGET_LINK_LIBRARIES(Pipeline OTBCommon OTBIO)
\end{verbatim}

Now, create a \code{Pipeline.cxx} file.

\input Pipeline.tex

Once this file is written you just have to run \code{make}. The \code{ccmake} is not required anymore.

Get one image from the \code{OTB/Examples/Data} directory in the OTB sources. For example get \code{QB\_Suburb.png}. 

Now, run your new program as \code{Pipeline QB\_Suburb.png output.png}. You obtain the file \code{output.png} which is the same image as \code{QB\_Suburb.png}. When you triggered the \code{Update()} method, OTB opened the original image and wrote it back under another name. 

Well\ldots that's nice but a bit complicated for a copy program!

Wait a minute! We didn't specify the file format anywhere! Let's try \code{Pipeline QB\_Suburb.png output.jpg}. And voila! The output image is a jpeg file. 

That's starting to be a bit more interesting: this is not just a program to copy image files, but also to convert between image formats.

Now it's time to do some processing in between.


\section{Filtering}
\label{sec:TutorialFiltering}

\index{Filter, Pipeline}

We are now going to insert a simple filter to do some processing between the reader and the writer.

Let's first add the two lines to the \code{CMakeLists.txt} file:

\small
\begin{verbatim}
ADD_EXECUTABLE(FilteringPipeline FilteringPipeline.cxx )
TARGET_LINK_LIBRARIES(FilteringPipeline OTBCommon OTBIO)
\end{verbatim}

\input{FilteringPipeline.tex}

Compile with \code{make} and execute as \code{FilteringPipeline QB\_Suburb.png output.png}.
 
You have the filtered version of your image in the \code{output.png} file.

Now, you can practice a bit and try to replace the filter by one of the 150+ filters which heritate from the \doxygen{otb}{ImageToImageFilter} class. You will definitly find some useful filter here!



% \section{Parsing arguments}
% \label{sec:TutorialParsing}
% 
% With the parser
% 
% \section{Viewer}
% 
% End the pipeline with a viewer
% 
% \section{GUI}
% 
% Basic GUI
% 
% \section{Better GUI}
% 
% Road extraction viewer



